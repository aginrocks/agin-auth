/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/admin/applications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get applications */
        get: operations["get_applications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get health of the service (returns "ok") */
        get: operations["get_health"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get login options
         * @description Gets available login options for the user. If the user is not found, returns only password option.
         */
        get: operations["get_login_options"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log in with password
         * @description If user is not found or the password isn't enabled for the user returns the same response as if the password was incorrect.
         */
        post: operations["login_with_password"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/pgp/challenge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get PGP challenge
         * @description Returns a challenge that needs to be signed with the user's PGP key.
         */
        get: operations["get_pgp_challenge"];
        put?: never;
        /**
         * Respond to PGP challenge
         * @description Sign the challenge obtained from `GET /api/login/pgp/challenge` with the user's PGP key and send the signature here to complete the login process.
         */
        post: operations["respond_to_pgp_challenge"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/recovery-codes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log in with a recovery code
         * @description **This endpoint can only be used as a second factor.** Each recovery code can be used only one time.
         */
        post: operations["login_with_recovery_code"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/totp": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Log in with TOTP
         * @description **This endpoint can only be used as a second factor.** TOTP is not considered secure enough to be used as a primary authentication method.
         */
        post: operations["login_with_totp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/webauthn/finish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Finish WebAuthn 2FA
         * @description **This endpoint can only be used as a second factor.** For passwordless authentication, see `/api/login/webauthn/passwordless/start`. Requires a previous call to `/api/login/webauthn/start` to initiate the login process.
         */
        post: operations["webauthn_finish_login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/login/webauthn/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start WebAuthn 2FA
         * @description **This endpoint can only be used as a second factor.** For passwordless authentication, see `/api/login/webauthn/passwordless/start`. Request a challenge to start the WebAuthn login process. After receiving a response from the browser, the client should call the `/api/login/webauthn/finish` endpoint to complete the login.
         */
        post: operations["webauthn_start_login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Register */
        post: operations["register"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get factors
         * @description Gets all authentication factors for the current user.
         */
        get: operations["get_factors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/pgp/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable PGP
         * @description Enables PGP authentication factor for the user. This factor can only be used as a first factor.
         */
        post: operations["enable_pgp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/recovery-codes/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable recovery codes
         * @description **Calling this endpoint again will regenerate the recovery codes.** The old codes will be forever lost.
         */
        post: operations["enable_recovery_codes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/totp/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable TOTP
         * @description Generates TOTP secret and saves it. To fully enable TOTP, a call to `/api/settings/factors/totp/enable/confirm` is required.
         */
        post: operations["enable_totp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/totp/enable/confirm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm enabling TOTP
         * @description Confirm enabling TOTP by providing the TOTP code.
         */
        post: operations["confirm_enabling_totp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/webauthn/finish": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Finish WebAuthn setup
         * @description Requires a previous call to `/api/settings/factors/webauthn/start` to initiate the registration process.
         */
        post: operations["webauthn_finish_setup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/settings/factors/webauthn/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start WebAuthn setup
         * @description Request a challenge to start the WebAuthn registration process. After receiving a response from the browser, the client should call the `/api/settings/factors/webauthn/finish` endpoint to complete the registration.
         */
        post: operations["webauthn_start_setup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description A descriptor of a credential that can be used. */
        AllowCredentials: {
            /** @description The id of the credential. */
            id: string;
            /** @description <https://www.w3.org/TR/webauthn/#transport>
             *     may be usb, nfc, ble, internal */
            transports?: components["schemas"]["AuthenticatorTransport"][] | null;
            /** @description The type of credential. */
            type: string;
        };
        /** @example {
         *       "error": "TOTP is already enabled. To rotate your TOTP secret, disable it first and then enable it again."
         *     } */
        AlreadyEnabledError: {
            error: string;
        };
        /**
         * @description <https://www.w3.org/TR/webauthn/#enumdef-attestationconveyancepreference>
         * @enum {string}
         */
        AttestationConveyancePreference: "none" | "indirect" | "direct";
        /**
         * @description The type of attestation on the credential
         *
         *     <https://www.iana.org/assignments/webauthn/webauthn.xhtml>
         * @enum {string}
         */
        AttestationFormat: "packed" | "tpm" | "android-key" | "android-safetynet" | "fido-u2f" | "apple" | "none";
        /** @description <https://w3c.github.io/webauthn/#dictdef-authenticationextensionsclientoutputs>
         *     The default option here for Options are None, so it can be derived */
        AuthenticationExtensionsClientOutputs: {
            /** @description Indicates whether the client used the provided appid extension */
            appid?: boolean | null;
            hmac_get_secret?: null | components["schemas"]["HmacGetSecretOutput"];
        };
        /** @description <https://w3c.github.io/webauthn/#authenticatorassertionresponse> */
        AuthenticatorAssertionResponseRaw: {
            /** @description Raw authenticator data. */
            authenticatorData: string;
            /** @description Signed client data. */
            clientDataJSON: string;
            /** @description Signature */
            signature: string;
            /** @description Optional userhandle. */
            userHandle?: string | null;
        };
        /**
         * @description The authenticator attachment hint. This is NOT enforced, and is only used
         *     to help a user select a relevant authenticator type.
         *
         *     <https://www.w3.org/TR/webauthn/#attachment>
         * @enum {string}
         */
        AuthenticatorAttachment: "platform" | "cross-platform";
        /** @description <https://w3c.github.io/webauthn/#authenticatorattestationresponse> */
        AuthenticatorAttestationResponseRaw: {
            /** @description <https://w3c.github.io/webauthn/#dom-authenticatorattestationresponse-attestationobject> */
            attestationObject: string;
            /** @description <https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson> */
            clientDataJSON: string;
            /** @description <https://w3c.github.io/webauthn/#dom-authenticatorattestationresponse-gettransports> */
            transports?: components["schemas"]["AuthenticatorTransport"][] | null;
        };
        /** @description <https://www.w3.org/TR/webauthn/#dictdef-authenticatorselectioncriteria> */
        AuthenticatorSelectionCriteria: {
            authenticatorAttachment?: null | components["schemas"]["AuthenticatorAttachment"];
            /** @description Hint to the credential to create a resident key. Note this can not be enforced
             *     or validated, so the authenticator may choose to ignore this parameter.
             *     <https://www.w3.org/TR/webauthn/#resident-credential> */
            requireResidentKey: boolean;
            residentKey?: null | components["schemas"]["ResidentKeyRequirement"];
            /** @description The user verification level to request during registration. Depending on if this
             *     authenticator provides verification may affect future interactions as this is
             *     associated to the credential during registration. */
            userVerification: components["schemas"]["UserVerificationPolicy"];
        };
        /**
         * @description <https://www.w3.org/TR/webauthn/#enumdef-authenticatortransport>
         * @enum {string}
         */
        AuthenticatorTransport: "usb" | "nfc" | "ble" | "internal" | "hybrid" | "test" | "unknown";
        /** @example {
         *       "error": "User with this username or email already existsd"
         *     } */
        BadRequestError: {
            error: string;
        };
        /** @enum {string} */
        ClientType: "public" | "confidential";
        /** @example {
         *       "success": true
         *     } */
        ConfirmTotpResponse: {
            success: boolean;
        };
        /** @example {
         *       "success": true,
         *       "id": "60c72b2f9b1d8c001c8e4f5a"
         *     } */
        CreateSuccess: {
            id: string;
            success: boolean;
        };
        /** @description A JSON serializable challenge which is issued to the user's web browser
         *     for handling. This is meant to be opaque, that is, you should not need
         *     to inspect or alter the content of the struct - you should serialise it
         *     and transmit it to the client only. */
        CreationChallengeResponse: {
            /** @description The options. */
            publicKey: components["schemas"]["PublicKeyCredentialCreationOptions"];
        };
        /** @description <https://www.w3.org/TR/webauthn-3/#sctn-authenticator-credential-properties-extension> */
        CredProps: {
            /** @description A user agent supplied hint that this credential *may* have created a resident key. It is
             *     retured from the user agent, not the authenticator meaning that this is an unreliable
             *     signal.
             *
             *     Note that this extension is UNSIGNED and may have been altered by page javascript. */
            rk: boolean;
        };
        /** @description The desired options for the client's use of the `credProtect` extension
         *
         *     <https://fidoalliance.org/specs/fido-v2.1-rd-20210309/fido-client-to-authenticator-protocol-v2.1-rd-20210309.html#sctn-credProtect-extension> */
        CredProtect: {
            /** @description The credential policy to enact */
            credentialProtectionPolicy: components["schemas"]["CredentialProtectionPolicy"];
            /** @description Whether it is better for the authenticator to fail to create a
             *     credential rather than ignore the protection policy
             *     If no value is provided, the client treats it as `false`. */
            enforceCredentialProtectionPolicy?: boolean | null;
        };
        /**
         * @description Valid credential protection policies
         * @enum {string}
         */
        CredentialProtectionPolicy: "userVerificationOptional" | "userVerificationOptionalWithCredentialIDList" | "userVerificationRequired";
        EnablePgpBody: {
            /** @description The display name for the TOTP factor (for example authenticator app name). */
            display_name: string;
            public_key: string;
        };
        /** @example {
         *       "success": true
         *     } */
        EnablePgpResponse: {
            success: boolean;
        };
        EnableRecoveryCodesResponse: {
            /** @description Generated security codes. Save them securely as they won't be shown again. */
            codes: string[];
        };
        EnableTotpBody: {
            /** @description The display name for the TOTP factor (for example authenticator app name). */
            display_name: string;
        };
        EnableTotpResponse: {
            /** @description QR code URL that'll add the TOTP factor to your authenticator app. Won't be shown again. */
            qr: string;
            /** @description The secret won't be shown again, so save it securely. */
            secret: string;
        };
        /** @enum {string} */
        FirstFactor: "password" | "webauthnpasswordless" | "pgp";
        /** @description The inputs to the hmac secret if it was created during registration.
         *
         *     <https://fidoalliance.22org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-hmac-secret-extension> */
        HmacGetSecretInput: {
            /** @description Retrieve a symmetric secrets from the authenticator with this input. */
            output1: string;
            /** @description Rotate the secret in the same operation. */
            output2?: string | null;
        };
        /** @description The response to a hmac get secret request. */
        HmacGetSecretOutput: {
            /** @description Output of HMAC(Salt 1 || Client Secret) */
            output1: string;
            /** @description Output of HMAC(Salt 2 || Client Secret) */
            output2?: string | null;
        };
        /** @example {
         *       "error": "Invalid 2FA code"
         *     } */
        Invalid2faCode: {
            error: string;
        };
        /** @example {
         *       "error": "Invalid recovery code"
         *     } */
        InvalidRecoveryCode: {
            error: string;
        };
        /** @example {
         *       "error": "Invalid signature"
         *     } */
        InvalidSignature: {
            error: string;
        };
        /** @example {
         *       "error": "Invalid username or password"
         *     } */
        InvalidUserOrPass: {
            error: string;
        };
        LoginBody: {
            password: string;
            /** @description Username or email address */
            username: string;
        };
        /**
         * @description Request in residentkey workflows that conditional mediation should be used
         *     in the UI, or not.
         * @enum {string}
         */
        Mediation: "conditional";
        OptionsRepsonse: {
            options: components["schemas"]["FirstFactor"][];
            recent_factor?: null | components["schemas"]["FirstFactor"];
        };
        PgpChallengeBody: {
            /** @description Signature of the challenge obtained from `GET /api/login/pgp/challenge` */
            signature: string;
            /** @description Username or email address */
            username: string;
        };
        PgpChallengeResponse: {
            challenge: string;
        };
        /** @description Public key cryptographic parameters */
        PubKeyCredParams: {
            /**
             * Format: int64
             * @description The algorithm in use defined by COSE.
             */
            alg: number;
            /** @description The type of public-key credential. */
            type: string;
        };
        PublicApplication: {
            _id: string;
            allowed_groups: string[];
            client_id: string;
            client_type: components["schemas"]["ClientType"];
            icon: string;
            name: string;
            redirect_uris: string[];
            slug: string;
        };
        PublicAuthFactors: {
            password: components["schemas"]["PublicPasswordFactor"];
            pgp: components["schemas"]["PublicPGPFactor"][];
            recent: components["schemas"]["RecentFactors"];
            recovery_codes: components["schemas"]["PublicRecoveryCodeFactor"];
            totp?: null | components["schemas"]["PublicTOTPFactor"];
            webauthn: components["schemas"]["PublicWebAuthnFactor"][];
        };
        /** @description A client response to an authentication challenge. This contains all required
         *     information to asses and assert trust in a credentials legitimacy, followed
         *     by authentication to a user.
         *
         *     You should not need to handle the inner content of this structure - you should
         *     provide this to the correctly handling function of Webauthn only. */
        PublicKeyCredential: {
            /** @description Unsigned Client processed extensions. */
            extensions?: components["schemas"]["AuthenticationExtensionsClientOutputs"];
            /** @description The credential Id, likely base64 */
            id: string;
            /** @description The binary of the credential id. */
            rawId: string;
            /** @description The authenticator response. */
            response: components["schemas"]["AuthenticatorAssertionResponseRaw"];
            /** @description The authenticator type. */
            type: string;
        };
        /** @description <https://w3c.github.io/webauthn/#dictionary-makecredentialoptions> */
        PublicKeyCredentialCreationOptions: {
            attestation?: null | components["schemas"]["AttestationConveyancePreference"];
            /** @description The list of attestation formats that the RP will accept. */
            attestationFormats?: components["schemas"]["AttestationFormat"][] | null;
            authenticatorSelection?: null | components["schemas"]["AuthenticatorSelectionCriteria"];
            /** @description The one-time challenge for the credential to sign. */
            challenge: string;
            /** @description Credential ID's that are excluded from being able to be registered. */
            excludeCredentials?: components["schemas"]["PublicKeyCredentialDescriptor"][] | null;
            extensions?: null | components["schemas"]["RequestRegistrationExtensions"];
            /** @description Hints defining which credentials may be used in this operation. */
            hints?: components["schemas"]["PublicKeyCredentialHints"][] | null;
            /** @description The set of cryptographic types allowed by this server. */
            pubKeyCredParams: components["schemas"]["PubKeyCredParams"][];
            /** @description The relying party */
            rp: components["schemas"]["RelyingParty"];
            /**
             * Format: int32
             * @description The timeout for the authenticator to stop accepting the operation
             */
            timeout?: number | null;
            /** @description The user. */
            user: components["schemas"]["User"];
        };
        /** @description <https://www.w3.org/TR/webauthn/#dictdef-publickeycredentialdescriptor> */
        PublicKeyCredentialDescriptor: {
            /** @description The credential id. */
            id: string;
            /** @description The allowed transports for this credential. Note this is a hint, and is NOT
             *     enforced. */
            transports?: components["schemas"]["AuthenticatorTransport"][] | null;
            /** @description The type of credential */
            type: string;
        };
        /**
         * @description A hint as to the class of device that is expected to fufil this operation.
         *
         *     <https://www.w3.org/TR/webauthn-3/#enumdef-publickeycredentialhints>
         * @enum {string}
         */
        PublicKeyCredentialHints: "security-key" | "client-device" | "hybrid";
        /** @description The requested options for the authentication */
        PublicKeyCredentialRequestOptions: {
            /** @description The set of credentials that are allowed to sign this challenge. */
            allowCredentials: components["schemas"]["AllowCredentials"][];
            /** @description The challenge that should be signed by the authenticator. */
            challenge: string;
            extensions?: null | components["schemas"]["RequestAuthenticationExtensions"];
            /** @description Hints defining which types credentials may be used in this operation. */
            hints?: components["schemas"]["PublicKeyCredentialHints"][] | null;
            /** @description The relying party ID. */
            rpId: string;
            /**
             * Format: int32
             * @description The timeout for the authenticator in case of no interaction.
             */
            timeout?: number | null;
            /** @description The verification policy the browser will request. */
            userVerification: components["schemas"]["UserVerificationPolicy"];
        };
        PublicPGPFactor: {
            display_name: string;
            fingerprint: string;
        };
        PublicPasswordFactor: {
            is_set: boolean;
        };
        PublicRecoveryCodeFactor: {
            /** Format: int32 */
            remaining_codes: number;
        };
        PublicTOTPFactor: {
            display_name: string;
            fully_enabled: boolean;
        };
        PublicWebAuthnFactor: {
            display_name: string;
        };
        RecentFactors: {
            first_factor?: null | components["schemas"]["FirstFactor"];
            second_factor?: null | components["schemas"]["SecondFactor"];
        };
        RecoveryCodeLoginBody: {
            code: string;
        };
        RegisterBody: {
            display_name: string;
            email: string;
            first_name: string;
            last_name: string;
            password: string;
            preferred_username: string;
        };
        /** @description A client response to a registration challenge. This contains all required
         *     information to assess and assert trust in a credential's legitimacy, followed
         *     by registration to a user.
         *
         *     You should not need to handle the inner content of this structure - you should
         *     provide this to the correctly handling function of Webauthn only.
         *     <https://w3c.github.io/webauthn/#iface-pkcredential> */
        RegisterPublicKeyCredential: {
            /** @description Unsigned Client processed extensions. */
            extensions?: components["schemas"]["RegistrationExtensionsClientOutputs"];
            /** @description The id of the PublicKey credential, likely in base64.
             *
             *     This is NEVER actually
             *     used in a real registration, because the true credential ID is taken from the
             *     attestation data. */
            id: string;
            /** @description The id of the credential, as binary.
             *
             *     This is NEVER actually
             *     used in a real registration, because the true credential ID is taken from the
             *     attestation data. */
            rawId: string;
            /** @description <https://w3c.github.io/webauthn/#dom-publickeycredential-response> */
            response: components["schemas"]["AuthenticatorAttestationResponseRaw"];
            /** @description The type of credential. */
            type: string;
        };
        /** @description <https://w3c.github.io/webauthn/#dictdef-authenticationextensionsclientoutputs>
         *     The default option here for Options are None, so it can be derived */
        RegistrationExtensionsClientOutputs: {
            /** @description Indicates whether the client used the provided appid extension */
            appid?: boolean | null;
            cred_props?: null | components["schemas"]["CredProps"];
            cred_protect?: null | components["schemas"]["CredentialProtectionPolicy"];
            /** @description Indicates if the client successfully applied a HMAC Secret */
            hmac_secret?: boolean | null;
            /**
             * Format: int32
             * @description Indicates the current minimum PIN length
             */
            min_pin_length?: number | null;
        };
        /** @description Relying Party Entity */
        RelyingParty: {
            /** @description The id of the relying party. */
            id: string;
            /** @description The name of the relying party. */
            name: string;
        };
        /** @description Extension option inputs for PublicKeyCredentialRequestOptions
         *
         *     Implements \[AuthenticatorExtensionsClientInputs\] from the spec */
        RequestAuthenticationExtensions: {
            /** @description The `appid` extension options */
            appid?: string | null;
            hmacGetSecret?: null | components["schemas"]["HmacGetSecretInput"];
            /** @description ⚠️  - Browsers do not support this!
             *     Uvm */
            uvm?: boolean | null;
        };
        /** @description A JSON serializable challenge which is issued to the user's webbrowser
         *     for handling. This is meant to be opaque, that is, you should not need
         *     to inspect or alter the content of the struct - you should serialise it
         *     and transmit it to the client only. */
        RequestChallengeResponse: {
            mediation?: null | components["schemas"]["Mediation"];
            /** @description The options. */
            publicKey: components["schemas"]["PublicKeyCredentialRequestOptions"];
        };
        /** @description Extension option inputs for PublicKeyCredentialCreationOptions.
         *
         *     Implements \[AuthenticatorExtensionsClientInputs\] from the spec. */
        RequestRegistrationExtensions: (null | components["schemas"]["CredProtect"]) & {
            /** @description ⚠️  - This extension result is always unsigned, and only indicates if the
             *     browser *requests* a residentKey to be created. It has no bearing on the
             *     true rk state of the credential. */
            credProps?: boolean | null;
            /** @description ⚠️  - Browsers support the *creation* of the secret, but not the retrieval of it.
             *     CTAP2.1 create hmac secret */
            hmacCreateSecret?: boolean | null;
            /** @description CTAP2.1 Minumum pin length */
            minPinLength?: boolean | null;
            /** @description ⚠️  - Browsers do not support this!
             *     Uvm */
            uvm?: boolean | null;
        };
        /**
         * @description The Relying Party's requirements for client-side discoverable credentials.
         *
         *     <https://www.w3.org/TR/webauthn-2/#enumdef-residentkeyrequirement>
         * @enum {string}
         */
        ResidentKeyRequirement: "discouraged" | "preferred" | "required";
        /** @enum {string} */
        SecondFactor: "totp" | "webauthn" | "recoverycode";
        SuccessfulLoginResponse: {
            recent_factor?: null | components["schemas"]["SecondFactor"];
            second_factors?: components["schemas"]["SecondFactor"][] | null;
            two_factor_required: boolean;
        };
        TotpCodeBody: {
            /** @description TOTP code to confirm enabling the factor. */
            code: string;
        };
        /** @example {
         *       "error": "Unauthorized"
         *     } */
        UnauthorizedError: {
            error: string;
        };
        /** @description User Entity */
        User: {
            /** @description The user's preferred name for display. This value **can** change, so
             *     **must not** be used as a primary key. */
            displayName: string;
            /** @description The user's id in base64 form. This MUST be a unique id, and
             *     must NOT contain personally identifying information, as this value can NEVER
             *     be changed. If in doubt, use a UUID. */
            id: string;
            /** @description A detailed name for the account, such as an email address. This value
             *     **can** change, so **must not** be used as a primary key. */
            name: string;
        };
        /**
         * @description Defines the User Authenticator Verification policy. This is documented
         *     <https://w3c.github.io/webauthn/#enumdef-userverificationrequirement>, and each
         *     variant lists it's effects.
         *
         *     To be clear, Verification means that the Authenticator perform extra or supplementary
         *     interaction with the user to verify who they are. An example of this is Apple Touch Id
         *     required a fingerprint to be verified, or a yubico device requiring a pin in addition to
         *     a touch event.
         *
         *     An example of a non-verified interaction is a yubico device with no pin where touch is
         *     the only interaction - we only verify a user is present, but we don't have extra details
         *     to the legitimacy of that user.
         *
         *     As UserVerificationPolicy is *only* used in credential registration, this stores the
         *     verification state of the credential in the persisted credential. These persisted
         *     credentials define which UserVerificationPolicy is issued during authentications.
         *
         *     **IMPORTANT** - Due to limitations of the webauthn specification, CTAP devices, and browser
         *     implementations, the only secure choice as an RP is *required*.
         *
         *     > ⚠️  **WARNING** - discouraged is marked with a warning, as some authenticators
         *     > will FORCE verification during registration but NOT during authentication.
         *     > This makes it impossible for a relying party to *consistently* enforce user verification,
         *     > which can confuse users and lead them to distrust user verification is being enforced.
         *
         *     > ⚠️  **WARNING** - preferred can lead to authentication errors in some cases due to browser
         *     > peripheral exchange allowing authentication verification bypass. Webauthn RS is not vulnerable
         *     > to these bypasses due to our
         *     > tracking of UV during registration through authentication, however preferred can cause
         *     > legitimate credentials to not prompt for UV correctly due to browser perhipheral exchange
         *     > leading Webauthn RS to deny them in what should otherwise be legitimate operations.
         * @enum {string}
         */
        UserVerificationPolicy: "required" | "preferred" | "discouraged";
        /** @example {
         *       "success": true
         *     } */
        WebAuthnFinishSuccess: {
            success: boolean;
        };
        WebAuthnRegistrationBody: {
            display_name: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    get_applications: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PublicApplication"][];
                };
            };
        };
    };
    get_health: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": string;
                };
            };
        };
    };
    get_login_options: {
        parameters: {
            query: {
                /** @description Username or email address of the user the factors are requested for */
                username: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OptionsRepsonse"];
                };
            };
        };
    };
    login_with_password: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessfulLoginResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InvalidUserOrPass"];
                };
            };
        };
    };
    get_pgp_challenge: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PgpChallengeResponse"];
                };
            };
        };
    };
    respond_to_pgp_challenge: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PgpChallengeBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PgpChallengeResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InvalidSignature"];
                };
            };
        };
    };
    login_with_recovery_code: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RecoveryCodeLoginBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessfulLoginResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InvalidRecoveryCode"];
                };
            };
        };
    };
    login_with_totp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TotpCodeBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessfulLoginResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Invalid2faCode"];
                };
            };
        };
    };
    webauthn_finish_login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PublicKeyCredential"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SuccessfulLoginResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    webauthn_start_login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestChallengeResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    register: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateSuccess"];
                };
            };
            /** @description BadRequest */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BadRequestError"];
                };
            };
        };
    };
    get_factors: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PublicAuthFactors"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    enable_pgp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnablePgpBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnablePgpResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    enable_recovery_codes: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnableRecoveryCodesResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    enable_totp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EnableTotpBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EnableTotpResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
            /** @description Already Enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyEnabledError"];
                };
            };
        };
    };
    confirm_enabling_totp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TotpCodeBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ConfirmTotpResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
            /** @description Already Enabled */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyEnabledError"];
                };
            };
        };
    };
    webauthn_finish_setup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RegisterPublicKeyCredential"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebAuthnFinishSuccess"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
    webauthn_start_setup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebAuthnRegistrationBody"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreationChallengeResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UnauthorizedError"];
                };
            };
        };
    };
}
